<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dasf.ml.cluster &mdash; DASF 1.0b5 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="dasf.ml.cluster.agglomerative" href="agglomerative/index.html" />
    <link rel="prev" title="dasf.ml" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            DASF
          </a>
              <div class="version">
                1.0b5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../principles.html">Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../../api.html">DASF API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf</span></code></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../../index.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../../datasets/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.datasets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../debug/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.debug</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../feature_extraction/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.feature_extraction</span></code></a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../pipeline/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.pipeline</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../profile/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.profile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../transforms/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.transforms</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../utils/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.utils</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">DASF</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../api.html">DASF API Reference</a></li>
          <li class="breadcrumb-item"><a href="../../index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf</span></code></a></li>
          <li class="breadcrumb-item"><a href="../index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml</span></code></a></li>
      <li class="breadcrumb-item active"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/autoapi/dasf/ml/cluster/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-dasf.ml.cluster">
<span id="dasf-ml-cluster"></span><h1><a class="reference internal" href="#module-dasf.ml.cluster" title="dasf.ml.cluster"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster</span></code></a><a class="headerlink" href="#module-dasf.ml.cluster" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="agglomerative/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster.agglomerative</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="classifier/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster.classifier</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="dbscan/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster.dbscan</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="hdbscan/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster.hdbscan</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="kmeans/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster.kmeans</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="som/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster.som</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="spectral/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dasf.ml.cluster.spectral</span></code></a></li>
</ul>
</div>
</section>
<section id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Permalink to this heading"></a></h2>
<section id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this heading"></a></h3>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasf.ml.cluster.AgglomerativeClustering" title="dasf.ml.cluster.AgglomerativeClustering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AgglomerativeClustering</span></code></a></p></td>
<td><p>Agglomerative Clustering</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasf.ml.cluster.KMeans" title="dasf.ml.cluster.KMeans"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KMeans</span></code></a></p></td>
<td><p>K-Means clustering.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasf.ml.cluster.DBSCAN" title="dasf.ml.cluster.DBSCAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DBSCAN</span></code></a></p></td>
<td><p>Perform DBSCAN clustering from vector array or distance matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dasf.ml.cluster.SOM" title="dasf.ml.cluster.SOM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SOM</span></code></a></p></td>
<td><p>Initializes a Self Organizing Maps.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dasf.ml.cluster.SpectralClustering" title="dasf.ml.cluster.SpectralClustering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpectralClustering</span></code></a></p></td>
<td><p>Apply clustering to a projection of the normalized Laplacian.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="dasf.ml.cluster.AgglomerativeClustering">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dasf.ml.cluster.</span></span><span class="sig-name descname"><span class="pre">AgglomerativeClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affinity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linkage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'single'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_full_tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.AgglomerativeClustering" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="classifier/index.html#dasf.ml.cluster.classifier.ClusterClassifier" title="dasf.ml.cluster.classifier.ClusterClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dasf.ml.cluster.classifier.ClusterClassifier</span></code></a></p>
<p>Agglomerative Clustering</p>
<p>Recursively merges the pair of clusters that minimally increases
a given linkage distance.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<section id="parameters">
<h4>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading"></a></h4>
<dl>
<dt>n_clusters<span class="classifier">int or None, default=2</span></dt><dd><p>The number of clusters to find. It must be <code class="docutils literal notranslate"><span class="pre">None</span></code> if
<code class="docutils literal notranslate"><span class="pre">distance_threshold</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt>affinity<span class="classifier">str or callable, default=’euclidean’</span></dt><dd><p>Metric used to compute the linkage. Can be “euclidean”, “l1”, “l2”,
“manhattan”, “cosine”, or “precomputed”.
If linkage is “ward”, only “euclidean” is accepted.
If “precomputed”, a distance matrix (instead of a similarity matrix)
is needed as input for the fit method.</p>
</dd>
<dt>memory<span class="classifier">str or object with the joblib.Memory interface, default=None</span></dt><dd><p>Used to cache the output of the computation of the tree.
By default, no caching is done. If a string is given, it is the
path to the caching directory.</p>
</dd>
<dt>connectivity<span class="classifier">array-like or callable, default=None</span></dt><dd><p>Connectivity matrix. Defines for each sample the neighboring
samples following a given structure of the data.
This can be a connectivity matrix itself or a callable that transforms
the data into a connectivity matrix, such as derived from
kneighbors_graph. Default is <code class="docutils literal notranslate"><span class="pre">None</span></code>, i.e, the
hierarchical clustering algorithm is unstructured.</p>
</dd>
<dt>compute_full_tree<span class="classifier">‘auto’ or bool, default=’auto’</span></dt><dd><p>Stop early the construction of the tree at <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code>. This is
useful to decrease computation time if the number of clusters is not
small compared to the number of samples. This option is useful only
when specifying a connectivity matrix. Note also that when varying the
number of clusters and using caching, it may be advantageous to compute
the full tree. It must be <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">distance_threshold</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>. By default <cite>compute_full_tree</cite> is “auto”, which is equivalent
to <cite>True</cite> when <cite>distance_threshold</cite> is not <cite>None</cite> or that <cite>n_clusters</cite>
is inferior to the maximum between 100 or <cite>0.02 * n_samples</cite>.
Otherwise, “auto” is equivalent to <cite>False</cite>.</p>
</dd>
<dt>linkage<span class="classifier">{‘ward’, ‘complete’, ‘average’, ‘single’}, default=’ward’</span></dt><dd><p>Which linkage criterion to use. The linkage criterion determines which
distance to use between sets of observation. The algorithm will merge
the pairs of cluster that minimize this criterion.</p>
<ul class="simple">
<li><p>‘ward’ minimizes the variance of the clusters being merged.</p></li>
<li><p>‘average’ uses the average of the distances of each observation of
the two sets.</p></li>
<li><p>‘complete’ or ‘maximum’ linkage uses the maximum distances between
all observations of the two sets.</p></li>
<li><p>‘single’ uses the minimum of the distances between all observations
of the two sets.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span>Added the ‘single’ option</p>
</div>
</dd>
<dt>distance_threshold<span class="classifier">float, default=None</span></dt><dd><p>The linkage distance threshold above which, clusters will not be
merged. If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> must be <code class="docutils literal notranslate"><span class="pre">None</span></code> and
<code class="docutils literal notranslate"><span class="pre">compute_full_tree</span></code> must be <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.</span></p>
</div>
</dd>
<dt>compute_distances<span class="classifier">bool, default=False</span></dt><dd><p>Computes distances between clusters even if <cite>distance_threshold</cite> is not
used. This can be used to make dendrogram visualization, but introduces
a computational and memory overhead.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</dd>
<dt>n_neighbors<span class="classifier">int, default = 15</span></dt><dd><p>The number of neighbors to compute when connectivity = “knn”</p>
</dd>
<dt>output_type<span class="classifier">{‘input’, ‘cudf’, ‘cupy’, ‘numpy’, ‘numba’}, default=None</span></dt><dd><p>Variable to control output type of the results and attributes of the
estimator. If None, it’ll inherit the output type set at the module
level, cuml.global_settings.output_type. See Output Data Type
Configuration for more info.</p>
</dd>
</dl>
</section>
<section id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dasf.ml.cluster</span> <span class="kn">import</span> <span class="n">AgglomerativeClustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering</span> <span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering</span>
<span class="go">AgglomerativeClustering()</span>
</pre></div>
</div>
<p>For further informations see:
- <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html">https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html</a>
- <a class="reference external" href="https://docs.rapids.ai/api/cuml/stable/api.html#agglomerative-clustering">https://docs.rapids.ai/api/cuml/stable/api.html#agglomerative-clustering</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.AgglomerativeClustering._fit_cpu">
<span class="sig-name descname"><span class="pre">_fit_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convert_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.AgglomerativeClustering._fit_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.AgglomerativeClustering._fit_gpu">
<span class="sig-name descname"><span class="pre">_fit_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convert_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.AgglomerativeClustering._fit_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.AgglomerativeClustering._fit_predict_cpu">
<span class="sig-name descname"><span class="pre">_fit_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.AgglomerativeClustering._fit_predict_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.AgglomerativeClustering._fit_predict_gpu">
<span class="sig-name descname"><span class="pre">_fit_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.AgglomerativeClustering._fit_predict_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dasf.ml.cluster.</span></span><span class="sig-name descname"><span class="pre">KMeans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oversampling_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_samples_per_batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32768</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precompute_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="classifier/index.html#dasf.ml.cluster.classifier.ClusterClassifier" title="dasf.ml.cluster.classifier.ClusterClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dasf.ml.cluster.classifier.ClusterClassifier</span></code></a></p>
<p>K-Means clustering.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<section id="id1">
<h4>Parameters<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h4>
<dl class="simple">
<dt>n_clusters<span class="classifier">int, default=8</span></dt><dd><p>The number of clusters to form as well as the number of
centroids to generate.</p>
</dd>
</dl>
<p>init : {‘k-means++’, ‘random’}, callable or array-like of shape (n_clusters, n_features), default=’k-means++’</p>
<blockquote>
<div><p>Method for initialization:</p>
<p>‘k-means++’ : selects initial cluster centers for k-mean
clustering in a smart way to speed up convergence. See section
Notes in k_init for more details.</p>
<p>‘random’: choose <cite>n_clusters</cite> observations (rows) at random from data
for the initial centroids.</p>
<p>If an array is passed, it should be of shape (n_clusters, n_features)
and gives the initial centers.</p>
<p>If a callable is passed, it should take arguments X, n_clusters and a
random state and return an initialization.</p>
</div></blockquote>
<dl>
<dt>n_init<span class="classifier">int, default=10</span></dt><dd><p>Number of time the k-means algorithm will be run with different
centroid seeds. The final results will be the best output of
n_init consecutive runs in terms of inertia.</p>
</dd>
<dt>max_iter<span class="classifier">int, default=300</span></dt><dd><p>Maximum number of iterations of the k-means algorithm for a
single run.</p>
</dd>
<dt>tol<span class="classifier">float, default=1e-4</span></dt><dd><p>Relative tolerance with regards to Frobenius norm of the difference
in the cluster centers of two consecutive iterations to declare
convergence.</p>
</dd>
<dt>precompute_distances<span class="classifier">{‘auto’, True, False}, default=’auto’</span></dt><dd><p>Precompute distances (faster but takes more memory).</p>
<p>‘auto’ : do not precompute distances if n_samples * n_clusters &gt; 12
million. This corresponds to about 100MB overhead per job using
double precision. IMPORTANT: This is used only in Dask ML version.</p>
<p>True : always precompute distances.</p>
<p>False : never precompute distances.</p>
</dd>
<dt>verbose<span class="classifier">int, default=0</span></dt><dd><p>Verbosity mode.</p>
</dd>
<dt>random_state<span class="classifier">int, RandomState instance or None, default=None</span></dt><dd><p>Determines random number generation for centroid initialization. Use
an int to make the randomness deterministic.
See <span class="xref std std-term">Glossary</span>.</p>
</dd>
<dt>copy_x<span class="classifier">bool, default=True</span></dt><dd><p>When pre-computing distances it is more numerically accurate to center
the data first. If copy_x is True (default), then the original data is
not modified. If False, the original data is modified, and put back
before the function returns, but small numerical differences may be
introduced by subtracting and then adding the data mean. Note that if
the original data is not C-contiguous, a copy will be made even if
copy_x is False. If the original data is sparse, but not in CSR format,
a copy will be made even if copy_x is False.</p>
</dd>
<dt>n_jobs<span class="classifier">int, default=1</span></dt><dd><p>The number of OpenMP threads to use for the computation. Parallelism is
sample-wise on the main cython loop which assigns each sample to its
closest center. IMPORTANT: This is used only in Dask ML version.</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors.</p>
</dd>
<dt>init_max_iter<span class="classifier">int, default=None</span></dt><dd><p>Number of iterations for init step.</p>
</dd>
<dt>algorithm<span class="classifier">{“auto”, “full”, “elkan”}, default=”full”</span></dt><dd><p>K-means algorithm to use. The classical EM-style algorithm is “full”.
The “elkan” variation is more efficient on data with well-defined
clusters, by using the triangle inequality. However it’s more memory
intensive due to the allocation of an extra array of shape
(n_samples, n_clusters).</p>
<p>For now “auto” (kept for backward compatibiliy) chooses “elkan” but it
might change in the future for a better heuristic.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18: </span>Added Elkan algorithm</p>
</div>
</dd>
<dt>oversampling_factor<span class="classifier">int, default=2</span></dt><dd><p>The amount of points to sample in scalable k-means++ initialization
for potential centroids. Increasing this value can lead to better
initial centroids at the cost of memory. The total number of centroids
sampled in scalable k-means++ is oversampling_factor * n_clusters * 8.</p>
</dd>
<dt>max_samples_per_batch<span class="classifier">int, default=32768</span></dt><dd><p>The number of data samples to use for batches of the pairwise distance
computation. This computation is done throughout both fit predict. The
default should suit most cases. The total number of elements in the
batched pairwise distance computation is max_samples_per_batch *
n_clusters. It might become necessary to lower this number when
n_clusters becomes prohibitively large.</p>
</dd>
<dt>output_type<span class="classifier">{‘input’, ‘cudf’, ‘cupy’, ‘numpy’, ‘numba’}, default=None</span></dt><dd><p>Variable to control output type of the results and attributes of the
estimator. If None, it’ll inherit the output type set at the module
level, cuml.global_settings.output_type. See Output Data Type
Configuration for more info.</p>
</dd>
</dl>
</section>
<section id="see-also">
<h4>See Also<a class="headerlink" href="#see-also" title="Permalink to this heading"></a></h4>
<dl class="simple">
<dt>MiniBatchKMeans<span class="classifier">Alternative online implementation that does incremental</span></dt><dd><p>updates of the centers positions using mini-batches.
For large scale learning (say n_samples &gt; 10k) MiniBatchKMeans is
probably much faster than the default batch implementation.</p>
</dd>
</dl>
</section>
<section id="notes">
<h4>Notes<a class="headerlink" href="#notes" title="Permalink to this heading"></a></h4>
<p>The k-means problem is solved using either Lloyd’s or Elkan’s algorithm.</p>
<p>The average complexity is given by O(k n T), where n is the number of
samples and T is the number of iteration.</p>
<p>The worst case complexity is given by O(n^(k+2/p)) with
n = n_samples, p = n_features. (D. Arthur and S. Vassilvitskii,
‘How slow is the k-means method?’ SoCG2006)</p>
<p>In practice, the k-means algorithm is very fast (one of the fastest
clustering algorithms available), but it falls in local minima. That’s why
it can be useful to restart it several times.</p>
<p>If the algorithm stops before fully converging (because of <code class="docutils literal notranslate"><span class="pre">tol</span></code> or
<code class="docutils literal notranslate"><span class="pre">max_iter</span></code>), <code class="docutils literal notranslate"><span class="pre">labels_</span></code> and <code class="docutils literal notranslate"><span class="pre">cluster_centers_</span></code> will not be consistent,
i.e. the <code class="docutils literal notranslate"><span class="pre">cluster_centers_</span></code> will not be the means of the points in each
cluster. Also, the estimator will reassign <code class="docutils literal notranslate"><span class="pre">labels_</span></code> after the last
iteration to make <code class="docutils literal notranslate"><span class="pre">labels_</span></code> consistent with <code class="docutils literal notranslate"><span class="pre">predict</span></code> on the training
set.</p>
</section>
<section id="id2">
<h4>Examples<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dasf.ml.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">array([1, 0], dtype=int32)</span>
</pre></div>
</div>
<p>For further informations see:
- <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html</a>
- <a class="reference external" href="https://ml.dask.org/modules/generated/dask_ml.cluster.KMeans.html">https://ml.dask.org/modules/generated/dask_ml.cluster.KMeans.html</a>
- <a class="reference external" href="https://docs.rapids.ai/api/cuml/stable/api.html#k-means-clustering">https://docs.rapids.ai/api/cuml/stable/api.html#k-means-clustering</a>
- <a class="reference external" href="https://docs.rapids.ai/api/cuml/stable/api.html#cuml.dask.cluster.KMeans">https://docs.rapids.ai/api/cuml/stable/api.html#cuml.dask.cluster.KMeans</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._lazy_fit_cpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._lazy_fit_cpu" title="Permalink to this definition"></a></dt>
<dd><p>Compute Dask k-means clustering.</p>
<section id="id3">
<h5>Parameters<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>Training instances to cluster. It must be noted that the data
will be converted to C ordering, which will cause a memory
copy if the given data is not C-contiguous.
If a sparse matrix is passed, a copy will be made if it&amp;apos;s not in
CSR format.</p>
</dd>
<dt>y<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
<dt>sample_weight<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
</dl>
</section>
<section id="returns">
<h5>Returns<a class="headerlink" href="#returns" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>self</dt><dd><p>Fitted estimator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._lazy_fit_gpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._lazy_fit_gpu" title="Permalink to this definition"></a></dt>
<dd><p>Compute Dask CuML k-means clustering.</p>
<section id="id4">
<h5>Parameters<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>Training instances to cluster. It must be noted that the data
will be converted to C ordering, which will cause a memory
copy if the given data is not C-contiguous.
If a sparse matrix is passed, a copy will be made if it&amp;apos;s not in
CSR format.</p>
</dd>
<dt>y<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id5">
<h5>Returns<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>self</dt><dd><p>Fitted estimator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._fit_cpu">
<span class="sig-name descname"><span class="pre">_fit_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._fit_cpu" title="Permalink to this definition"></a></dt>
<dd><p>Compute Scikit Learn k-means clustering.</p>
<section id="id6">
<h5>Parameters<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>Training instances to cluster. It must be noted that the data
will be converted to C ordering, which will cause a memory
copy if the given data is not C-contiguous.
If a sparse matrix is passed, a copy will be made if it&amp;apos;s not in
CSR format.</p>
</dd>
<dt>y<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id7">
<h5>Returns<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>self</dt><dd><p>Fitted estimator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._fit_gpu">
<span class="sig-name descname"><span class="pre">_fit_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._fit_gpu" title="Permalink to this definition"></a></dt>
<dd><p>Compute CuML k-means clustering.</p>
<section id="id8">
<h5>Parameters<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>Training instances to cluster. It must be noted that the data
will be converted to C ordering, which will cause a memory
copy if the given data is not C-contiguous.
If a sparse matrix is passed, a copy will be made if it&amp;apos;s not in
CSR format.</p>
</dd>
<dt>y<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id9">
<h5>Returns<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>self</dt><dd><p>Fitted estimator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._lazy_fit_predict_cpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._lazy_fit_predict_cpu" title="Permalink to this definition"></a></dt>
<dd><p>Compute cluster centers and predict cluster index for each sample using
Dask ML.</p>
<p>Convenience method; equivalent to calling fit(X) followed by
predict(X).</p>
<section id="id10">
<h5>Parameters<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to transform.</p>
</dd>
<dt>y<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
<dt>sample_weight<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
</dl>
</section>
<section id="id11">
<h5>Returns<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._lazy_fit_predict_gpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._lazy_fit_predict_gpu" title="Permalink to this definition"></a></dt>
<dd><p>Compute cluster centers and predict cluster index for each sample using
Dask CuML.</p>
<p>Convenience method; equivalent to calling fit(X) followed by
predict(X).</p>
<section id="id12">
<h5>Parameters<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to transform.</p>
</dd>
<dt>y<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id13">
<h5>Returns<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._fit_predict_cpu">
<span class="sig-name descname"><span class="pre">_fit_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._fit_predict_cpu" title="Permalink to this definition"></a></dt>
<dd><p>Compute cluster centers and predict cluster index for each sample using
Scikit Learn.</p>
<p>Convenience method; equivalent to calling fit(X) followed by
predict(X).</p>
<section id="id14">
<h5>Parameters<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to transform.</p>
</dd>
<dt>y<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
<dt>sample_weight<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
</dl>
</section>
<section id="id15">
<h5>Returns<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._fit_predict_gpu">
<span class="sig-name descname"><span class="pre">_fit_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._fit_predict_gpu" title="Permalink to this definition"></a></dt>
<dd><p>Compute cluster centers and predict cluster index for each sample using
CuML.</p>
<p>Convenience method; equivalent to calling fit(X) followed by
predict(X).</p>
<section id="id16">
<h5>Parameters<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to transform.</p>
</dd>
<dt>y<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id17">
<h5>Returns<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._lazy_predict_cpu">
<span class="sig-name descname"><span class="pre">_lazy_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._lazy_predict_cpu" title="Permalink to this definition"></a></dt>
<dd><p>Predict the closest cluster each sample in X belongs to using Dask ML.</p>
<p>In the vector quantization literature, <cite>cluster_centers_</cite> is called
the code book and each value returned by <cite>predict</cite> is the index of
the closest code in the code book.</p>
<section id="id18">
<h5>Parameters<a class="headerlink" href="#id18" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to predict.</p>
</dd>
<dt>sample_weight<span class="classifier">Ignored</span></dt><dd><p>Not used, present here for API consistency by convention.</p>
</dd>
</dl>
</section>
<section id="id19">
<h5>Returns<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._lazy_predict_gpu">
<span class="sig-name descname"><span class="pre">_lazy_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._lazy_predict_gpu" title="Permalink to this definition"></a></dt>
<dd><p>Predict the closest cluster each sample in X belongs to using Dask
CuML.</p>
<p>In the vector quantization literature, <cite>cluster_centers_</cite> is called
the code book and each value returned by <cite>predict</cite> is the index of
the closest code in the code book.</p>
<section id="id20">
<h5>Parameters<a class="headerlink" href="#id20" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to predict.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id21">
<h5>Returns<a class="headerlink" href="#id21" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._predict_cpu">
<span class="sig-name descname"><span class="pre">_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._predict_cpu" title="Permalink to this definition"></a></dt>
<dd><p>Predict the closest cluster each sample in X belongs to using Scikit
Learn.</p>
<p>In the vector quantization literature, <cite>cluster_centers_</cite> is called
the code book and each value returned by <cite>predict</cite> is the index of
the closest code in the code book.</p>
<section id="id22">
<h5>Parameters<a class="headerlink" href="#id22" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to predict.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id23">
<h5>Returns<a class="headerlink" href="#id23" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._predict_gpu">
<span class="sig-name descname"><span class="pre">_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._predict_gpu" title="Permalink to this definition"></a></dt>
<dd><p>Predict the closest cluster each sample in X belongs to using CuML.</p>
<p>In the vector quantization literature, <cite>cluster_centers_</cite> is called
the code book and each value returned by <cite>predict</cite> is the index of
the closest code in the code book.</p>
<section id="id24">
<h5>Parameters<a class="headerlink" href="#id24" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to predict.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id25">
<h5>Returns<a class="headerlink" href="#id25" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._lazy_predict2_cpu">
<span class="sig-name descname"><span class="pre">_lazy_predict2_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._lazy_predict2_cpu" title="Permalink to this definition"></a></dt>
<dd><p>A block predict using Scikit Learn variant but for Dask.</p>
<p>In the vector quantization literature, <cite>cluster_centers_</cite> is called
the code book and each value returned by <cite>predict</cite> is the index of
the closest code in the code book.</p>
<section id="id26">
<h5>Parameters<a class="headerlink" href="#id26" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to predict.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id27">
<h5>Returns<a class="headerlink" href="#id27" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._lazy_predict2_gpu">
<span class="sig-name descname"><span class="pre">_lazy_predict2_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._lazy_predict2_gpu" title="Permalink to this definition"></a></dt>
<dd><p>A block predict using CuML variant but for Dask.</p>
<p>In the vector quantization literature, <cite>cluster_centers_</cite> is called
the code book and each value returned by <cite>predict</cite> is the index of
the closest code in the code book.</p>
<section id="id28">
<h5>Parameters<a class="headerlink" href="#id28" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span></dt><dd><p>New data to predict.</p>
</dd>
<dt>sample_weight<span class="classifier">array-like of shape (n_samples,), default=None</span></dt><dd><p>The weights for each observation in X. If None, all observations
are assigned equal weight.</p>
</dd>
</dl>
</section>
<section id="id29">
<h5>Returns<a class="headerlink" href="#id29" title="Permalink to this heading"></a></h5>
<dl class="simple">
<dt>labels<span class="classifier">ndarray of shape (n_samples,)</span></dt><dd><p>Index of the cluster each sample belongs to.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._predict2_cpu">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_predict2_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._predict2_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans._predict2_gpu">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_predict2_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans._predict2_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.KMeans.predict2">
<span class="sig-name descname"><span class="pre">predict2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.KMeans.predict2" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dasf.ml.cluster.DBSCAN">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dasf.ml.cluster.</span></span><span class="sig-name descname"><span class="pre">DBSCAN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_core_sample_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.DBSCAN" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="classifier/index.html#dasf.ml.cluster.classifier.ClusterClassifier" title="dasf.ml.cluster.classifier.ClusterClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dasf.ml.cluster.classifier.ClusterClassifier</span></code></a></p>
<p>Perform DBSCAN clustering from vector array or distance matrix.</p>
<p>DBSCAN - Density-Based Spatial Clustering of Applications with Noise.
Finds core samples of high density and expands clusters from them.
Good for data which contains clusters of similar density.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<section id="id30">
<h4>Parameters<a class="headerlink" href="#id30" title="Permalink to this heading"></a></h4>
<dl>
<dt>eps<span class="classifier">float, default=0.5</span></dt><dd><p>The maximum distance between two samples for one to be considered
as in the neighborhood of the other. This is not a maximum bound
on the distances of points within a cluster. This is the most
important DBSCAN parameter to choose appropriately for your data set
and distance function.</p>
</dd>
<dt>min_samples<span class="classifier">int, default=5</span></dt><dd><p>The number of samples (or total weight) in a neighborhood for a point
to be considered as a core point. This includes the point itself.</p>
</dd>
<dt>metric<span class="classifier">string, or callable, default=’euclidean’</span></dt><dd><p>The metric to use when calculating distance between instances in a
feature array. If metric is a string or callable, it must be one of
the options allowed by <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.metrics.pairwise_distances()</span></code> for
its metric parameter.
If metric is “precomputed”, X is assumed to be a distance matrix and
must be square. X may be a <span class="xref std std-term">Glossary</span>, in which
case only “nonzero” elements may be considered neighbors for DBSCAN.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span>metric <em>precomputed</em> to accept precomputed sparse matrix.</p>
</div>
</dd>
<dt>metric_params<span class="classifier">dict, default=None</span></dt><dd><p>Additional keyword arguments for the metric function.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19.</span></p>
</div>
</dd>
<dt>algorithm<span class="classifier">{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, default=’auto’</span></dt><dd><p>The algorithm to be used by the NearestNeighbors module
to compute pointwise distances and find nearest neighbors.
See NearestNeighbors module documentation for details.</p>
</dd>
<dt>leaf_size<span class="classifier">int, default=30</span></dt><dd><p>Leaf size passed to BallTree or cKDTree. This can affect the speed
of the construction and query, as well as the memory required
to store the tree. The optimal value depends
on the nature of the problem.</p>
</dd>
<dt>p<span class="classifier">float, default=None</span></dt><dd><p>The power of the Minkowski metric to be used to calculate distance
between points. If None, then <code class="docutils literal notranslate"><span class="pre">p=2</span></code> (equivalent to the Euclidean
distance).</p>
</dd>
<dt>n_jobs<span class="classifier">int, default=None</span></dt><dd><p>The number of parallel jobs to run.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p>
</dd>
<dt>output_type<span class="classifier">{‘input’, ‘cudf’, ‘cupy’, ‘numpy’, ‘numba’}, default=None</span></dt><dd><p>Variable to control output type of the results and attributes of the
estimator. If None, it’ll inherit the output type set at the module
level, cuml.global_settings.output_type. See Output Data Type
Configuration for more info.</p>
</dd>
<dt>calc_core_sample_indices(optional)<span class="classifier">boolean, default = True</span></dt><dd><p>Indicates whether the indices of the core samples should be calculated.
The the attribute <cite>core_sample_indices_</cite> will not be used, setting this
to False will avoid unnecessary kernel launches.</p>
</dd>
</dl>
</section>
<section id="id31">
<h4>Examples<a class="headerlink" href="#id31" title="Permalink to this heading"></a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dasf.ml.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">80</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering</span>
<span class="go">DBSCAN(eps=3, min_samples=2)</span>
</pre></div>
</div>
<p>For further informations see:
- <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN">https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN</a>
- <a class="reference external" href="https://docs.rapids.ai/api/cuml/stable/api.html#dbscan">https://docs.rapids.ai/api/cuml/stable/api.html#dbscan</a>
- <a class="reference external" href="https://docs.rapids.ai/api/cuml/stable/api.html#dbscan-clustering">https://docs.rapids.ai/api/cuml/stable/api.html#dbscan-clustering</a></p>
</section>
<section id="id32">
<h4>See Also<a class="headerlink" href="#id32" title="Permalink to this heading"></a></h4>
<dl class="simple">
<dt>OPTICS<span class="classifier">A similar clustering at multiple values of eps. Our implementation</span></dt><dd><p>is optimized for memory usage.</p>
</dd>
</dl>
</section>
<section id="references">
<h4>References<a class="headerlink" href="#references" title="Permalink to this heading"></a></h4>
<p>Ester, M., H. P. Kriegel, J. Sander, and X. Xu, “A Density-Based
Algorithm for Discovering Clusters in Large Spatial Databases with Noise”.
In: Proceedings of the 2nd International Conference on Knowledge Discovery
and Data Mining, Portland, OR, AAAI Press, pp. 226-231. 1996</p>
<p>Schubert, E., Sander, J., Ester, M., Kriegel, H. P., &amp; Xu, X. (2017).
DBSCAN revisited, revisited: why and how you should (still) use DBSCAN.
ACM Transactions on Database Systems (TODS), 42(3), 19.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.DBSCAN._lazy_fit_gpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.DBSCAN._lazy_fit_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.DBSCAN._fit_cpu">
<span class="sig-name descname"><span class="pre">_fit_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.DBSCAN._fit_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.DBSCAN._fit_gpu">
<span class="sig-name descname"><span class="pre">_fit_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.DBSCAN._fit_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.DBSCAN._lazy_fit_predict_gpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.DBSCAN._lazy_fit_predict_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.DBSCAN._fit_predict_cpu">
<span class="sig-name descname"><span class="pre">_fit_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.DBSCAN._fit_predict_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.DBSCAN._fit_predict_gpu">
<span class="sig-name descname"><span class="pre">_fit_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.DBSCAN._fit_predict_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dasf.ml.cluster.</span></span><span class="sig-name descname"><span class="pre">SOM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_len</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmaN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rateN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decay_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'exponential'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighborhood_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topology</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rectangular'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compact_support</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="classifier/index.html#dasf.ml.cluster.classifier.ClusterClassifier" title="dasf.ml.cluster.classifier.ClusterClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dasf.ml.cluster.classifier.ClusterClassifier</span></code></a></p>
<p>Initializes a Self Organizing Maps.</p>
<p>A rule of thumb to set the size of the grid for a dimensionality
reduction task is that it should contain 5*sqrt(N) neurons
where N is the number of samples in the dataset to analyze.</p>
<p>E.g. if your dataset has 150 samples, 5*sqrt(150) = 61.23
hence a map 8-by-8 should perform well.</p>
<section id="id33">
<h4>Parameters<a class="headerlink" href="#id33" title="Permalink to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">int</span></dt><dd><p>x dimension of the SOM.</p>
</dd>
<dt>y<span class="classifier">int</span></dt><dd><p>y dimension of the SOM.</p>
</dd>
<dt>input_len<span class="classifier">int</span></dt><dd><p>Number of the elements of the vectors in input.</p>
</dd>
<dt>sigma<span class="classifier">float, default=min(x,y)/2</span></dt><dd><p>Spread of the neighborhood function, needs to be adequate
to the dimensions of the map.</p>
</dd>
<dt>sigmaN<span class="classifier">float, default=0.01</span></dt><dd><p>Spread of the neighborhood function at last iteration.</p>
</dd>
<dt>learning_rate<span class="classifier">float, default=0.5</span></dt><dd><p>initial learning rate.</p>
</dd>
<dt>learning_rateN<span class="classifier">float, default=0.01</span></dt><dd><p>final learning rate</p>
</dd>
<dt>decay_function<span class="classifier">string, default=’exponential’</span></dt><dd><p>Function that reduces learning_rate and sigma at each iteration.
Possible values: ‘exponential’, ‘linear’, ‘aymptotic’</p>
</dd>
<dt>neighborhood_function<span class="classifier">string, default=’gaussian’</span></dt><dd><p>Function that weights the neighborhood of a position in the map.
Possible values: ‘gaussian’, ‘mexican_hat’, ‘bubble’, ‘triangle’</p>
</dd>
<dt>topology<span class="classifier">string, default=’rectangular’</span></dt><dd><p>Topology of the map.
Possible values: ‘rectangular’, ‘hexagonal’</p>
</dd>
<dt>activation_distance<span class="classifier">string, default=’euclidean’</span></dt><dd><p>Distance used to activate the map.
Possible values: ‘euclidean’, ‘cosine’, ‘manhattan’</p>
</dd>
<dt>random_seed<span class="classifier">int, default=None</span></dt><dd><p>Random seed to use.</p>
</dd>
<dt>n_parallel<span class="classifier">uint, default=#max_CUDA_threads or 500*#CPUcores</span></dt><dd><p>Number of samples to be processed at a time. Setting a too low
value may drastically lower performance due to under-utilization,
setting a too high value increases memory usage without granting
any significant performance benefit.</p>
</dd>
<dt>xp<span class="classifier">numpy or cupy, default=cupy if can be imported else numpy</span></dt><dd><p>Use numpy (CPU) or cupy (GPU) for computations.</p>
</dd>
<dt>std_coeff: float, default=0.5</dt><dd><p>Used to calculate gausssian exponent denominator:
d = 2*std_coeff**2*sigma**2</p>
</dd>
<dt>compact_support: bool, default=False</dt><dd><p>Cut the neighbor function to 0 beyond neighbor radius sigma</p>
</dd>
</dl>
</section>
<section id="id34">
<h4>Examples<a class="headerlink" href="#id34" title="Permalink to this heading"></a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dasf.ml.cluster</span> <span class="kn">import</span> <span class="n">SOM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">som</span> <span class="o">=</span> <span class="n">SOM</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">input_len</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">num_epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">som</span>
<span class="go">SOM(x=3, y=2, input_len=2, num_epochs=100)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._lazy_fit_cpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._lazy_fit_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._lazy_fit_gpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._lazy_fit_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._fit_cpu">
<span class="sig-name descname"><span class="pre">_fit_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._fit_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._fit_gpu">
<span class="sig-name descname"><span class="pre">_fit_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._fit_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._lazy_fit_predict_cpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._lazy_fit_predict_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._lazy_fit_predict_gpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._lazy_fit_predict_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._fit_predict_cpu">
<span class="sig-name descname"><span class="pre">_fit_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._fit_predict_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._fit_predict_gpu">
<span class="sig-name descname"><span class="pre">_fit_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._fit_predict_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._lazy_predict_cpu">
<span class="sig-name descname"><span class="pre">_lazy_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._lazy_predict_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._lazy_predict_gpu">
<span class="sig-name descname"><span class="pre">_lazy_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._lazy_predict_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._predict_cpu">
<span class="sig-name descname"><span class="pre">_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._predict_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._predict_gpu">
<span class="sig-name descname"><span class="pre">_predict_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._predict_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._lazy_quantization_error_cpu">
<span class="sig-name descname"><span class="pre">_lazy_quantization_error_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._lazy_quantization_error_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._lazy_quantization_error_gpu">
<span class="sig-name descname"><span class="pre">_lazy_quantization_error_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._lazy_quantization_error_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._quantization_error_cpu">
<span class="sig-name descname"><span class="pre">_quantization_error_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._quantization_error_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM._quantization_error_gpu">
<span class="sig-name descname"><span class="pre">_quantization_error_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM._quantization_error_gpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SOM.quantization_error">
<span class="sig-name descname"><span class="pre">quantization_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SOM.quantization_error" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dasf.ml.cluster.SpectralClustering">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dasf.ml.cluster.</span></span><span class="sig-name descname"><span class="pre">SpectralClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigen_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affinity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rbf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigen_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assign_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kmeans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coef0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">persist_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmeans_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SpectralClustering" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="classifier/index.html#dasf.ml.cluster.classifier.ClusterClassifier" title="dasf.ml.cluster.classifier.ClusterClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dasf.ml.cluster.classifier.ClusterClassifier</span></code></a></p>
<p>Apply clustering to a projection of the normalized Laplacian.</p>
<p>In practice Spectral Clustering is very useful when the structure of
the individual clusters is highly non-convex, or more generally when
a measure of the center and spread of the cluster is not a suitable
description of the complete cluster, such as when clusters are
nested circles on the 2D plane.</p>
<p>If the affinity matrix is the adjacency matrix of a graph, this method
can be used to find normalized graph cuts.</p>
<p>When calling <code class="docutils literal notranslate"><span class="pre">fit</span></code>, an affinity matrix is constructed using either
a kernel function such the Gaussian (aka RBF) kernel with Euclidean
distance <code class="docutils literal notranslate"><span class="pre">d(X,</span> <span class="pre">X)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>or a k-nearest neighbors connectivity matrix.</p>
<p>Alternatively, a user-provided affinity matrix can be specified by
setting <code class="docutils literal notranslate"><span class="pre">affinity='precomputed'</span></code>.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<section id="id35">
<h4>Parameters<a class="headerlink" href="#id35" title="Permalink to this heading"></a></h4>
<dl>
<dt>n_clusters<span class="classifier">int, default=8</span></dt><dd><p>The dimension of the projection subspace.</p>
</dd>
<dt>eigen_solver<span class="classifier">{‘arpack’, ‘lobpcg’, ‘amg’}, default=None</span></dt><dd><p>The eigenvalue decomposition strategy to use. AMG requires pyamg
to be installed. It can be faster on very large, sparse problems,
but may also lead to instabilities. If None, then <code class="docutils literal notranslate"><span class="pre">'arpack'</span></code> is
used.</p>
</dd>
<dt>n_components<span class="classifier">int, default=n_clusters</span></dt><dd><p>Number of eigenvectors to use for the spectral embedding</p>
</dd>
<dt>random_state<span class="classifier">int, RandomState instance, default=None</span></dt><dd><p>A pseudo random number generator used for the initialization of the
lobpcg eigenvectors decomposition when <code class="docutils literal notranslate"><span class="pre">eigen_solver='amg'</span></code> and by
the K-Means initialization. Use an int to make the randomness
deterministic.
See <span class="xref std std-term">Glossary</span>.</p>
</dd>
<dt>n_init<span class="classifier">int, default=10</span></dt><dd><p>Number of time the k-means algorithm will be run with different
centroid seeds. The final results will be the best output of n_init
consecutive runs in terms of inertia. Only used if
<code class="docutils literal notranslate"><span class="pre">assign_labels='kmeans'</span></code>.</p>
</dd>
<dt>gamma<span class="classifier">float, default=1.0</span></dt><dd><p>Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels.
Ignored for <code class="docutils literal notranslate"><span class="pre">affinity='nearest_neighbors'</span></code>.</p>
</dd>
<dt>affinity<span class="classifier">str or callable, default=’rbf’</span></dt><dd><dl class="simple">
<dt>How to construct the affinity matrix.</dt><dd><ul class="simple">
<li><p>‘nearest_neighbors’: construct the affinity matrix by computing a
graph of nearest neighbors.</p></li>
<li><p>‘rbf’: construct the affinity matrix using a radial basis function
(RBF) kernel.</p></li>
<li><p>‘precomputed’: interpret <code class="docutils literal notranslate"><span class="pre">X</span></code> as a precomputed affinity matrix,
where larger values indicate greater similarity between instances.</p></li>
<li><p>‘precomputed_nearest_neighbors’: interpret <code class="docutils literal notranslate"><span class="pre">X</span></code> as a sparse graph
of precomputed distances, and construct a binary affinity matrix
from the <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code> nearest neighbors of each instance.</p></li>
<li><p>one of the kernels supported by
<code class="xref py py-func docutils literal notranslate"><span class="pre">pairwise_kernels()</span></code>.</p></li>
</ul>
</dd>
</dl>
<p>Only kernels that produce similarity scores (non-negative values that
increase with similarity) should be used. This property is not checked
by the clustering algorithm.</p>
</dd>
<dt>n_neighbors<span class="classifier">int, default=10</span></dt><dd><p>Number of neighbors to use when constructing the affinity matrix using
the nearest neighbors method. Ignored for <code class="docutils literal notranslate"><span class="pre">affinity='rbf'</span></code>.</p>
</dd>
<dt>eigen_tol<span class="classifier">float, default=0.0</span></dt><dd><p>Stopping criterion for eigendecomposition of the Laplacian matrix
when <code class="docutils literal notranslate"><span class="pre">eigen_solver='arpack'</span></code>.</p>
</dd>
<dt>assign_labels<span class="classifier">{‘kmeans’, ‘discretize’}, default=’kmeans’</span></dt><dd><p>The strategy for assigning labels in the embedding space. There are two
ways to assign labels after the Laplacian embedding. k-means is a
popular choice, but it can be sensitive to initialization.
Discretization is another approach which is less sensitive to random
initialization.</p>
</dd>
<dt>degree<span class="classifier">float, default=3</span></dt><dd><p>Degree of the polynomial kernel. Ignored by other kernels.</p>
</dd>
<dt>coef0<span class="classifier">float, default=1</span></dt><dd><p>Zero coefficient for polynomial and sigmoid kernels.
Ignored by other kernels.</p>
</dd>
<dt>kernel_params<span class="classifier">dict of str to any, default=None</span></dt><dd><p>Parameters (keyword arguments) and values for kernel passed as
callable object. Ignored by other kernels.</p>
</dd>
<dt>n_jobs<span class="classifier">int, default=None</span></dt><dd><p>The number of parallel jobs to run when <cite>affinity=’nearest_neighbors’</cite>
or <cite>affinity=’precomputed_nearest_neighbors’</cite>. The neighbors search
will be done in parallel.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p>
</dd>
<dt>verbose<span class="classifier">bool, default=False</span></dt><dd><p>Verbosity mode.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</dd>
<dt>persist_embedding<span class="classifier">bool</span></dt><dd><p>Whether to persist the intermediate n_samples x n_components array used
for clustering.</p>
</dd>
<dt>kmeans_params<span class="classifier">dictionary of string to any, optional</span></dt><dd><p>Keyword arguments for the KMeans clustering used for the final
clustering.</p>
</dd>
</dl>
</section>
<section id="id36">
<h4>Examples<a class="headerlink" href="#id36" title="Permalink to this heading"></a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dasf.ml.cluster</span> <span class="kn">import</span> <span class="n">SpectralClustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering</span> <span class="o">=</span> <span class="n">SpectralClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">assign_labels</span><span class="o">=</span><span class="s1">&#39;discretize&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering</span>
<span class="go">SpectralClustering(assign_labels=&#39;discretize&#39;, n_clusters=2,</span>
<span class="go">    random_state=0)</span>
</pre></div>
</div>
<p>For further informations see:
- <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering">https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering</a>
- <a class="reference external" href="https://ml.dask.org/modules/generated/dask_ml.cluster.SpectralClustering.html">https://ml.dask.org/modules/generated/dask_ml.cluster.SpectralClustering.html</a></p>
</section>
<section id="id37">
<h4>Notes<a class="headerlink" href="#id37" title="Permalink to this heading"></a></h4>
<p>A distance matrix for which 0 indicates identical elements and high values
indicate very dissimilar elements can be transformed into an affinity /
similarity matrix that is well-suited for the algorithm by
applying the Gaussian (aka RBF, heat) kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">dist_matrix</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">delta</span></code> is a free parameter representing the width of the Gaussian
kernel.</p>
<p>An alternative is to take a symmetric version of the k-nearest neighbors
connectivity matrix of the points.</p>
<p>If the pyamg package is installed, it is used: this greatly
speeds up computation.</p>
</section>
<section id="id38">
<h4>References<a class="headerlink" href="#id38" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>Normalized cuts and image segmentation, 2000
Jianbo Shi, Jitendra Malik
<a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324</a></p></li>
<li><p>A Tutorial on Spectral Clustering, 2007
Ulrike von Luxburg
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323</a></p></li>
<li><p>Multiclass spectral clustering, 2003
Stella X. Yu, Jianbo Shi
<a class="reference external" href="https://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf">https://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf</a></p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SpectralClustering._fit_cpu">
<span class="sig-name descname"><span class="pre">_fit_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SpectralClustering._fit_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SpectralClustering._lazy_fit_predict_cpu">
<span class="sig-name descname"><span class="pre">_lazy_fit_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SpectralClustering._lazy_fit_predict_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dasf.ml.cluster.SpectralClustering._fit_predict_cpu">
<span class="sig-name descname"><span class="pre">_fit_predict_cpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dasf.ml.cluster.SpectralClustering._fit_predict_cpu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="dasf.ml" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="agglomerative/index.html" class="btn btn-neutral float-right" title="dasf.ml.cluster.agglomerative" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022--2023, UNICAMP.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>